// @flow
const IAPErrorCode = Object.freeze({
  E_IAP_NOT_AVAILABLE: 'E_IAP_NOT_AVAILABLE',
  E_UNKNOWN: 'E_UNKNOWN',
  E_USER_CANCELLED: 'E_USER_CANCELLED',
  E_USER_ERROR: 'E_USER_ERROR',
  E_ITEM_UNAVAILABLE: 'E_ITEM_UNAVAILABLE',
  E_REMOTE_ERROR: 'E_REMOTE_ERROR',
  E_NETWORK_ERROR: 'E_NETWORK_ERROR',
  E_SERVICE_ERROR: 'E_SERVICE_ERROR',
  E_RECEIPT_FAILED: 'E_RECEIPT_FAILED',
  E_RECEIPT_FINISHED_FAILED: 'E_RECEIPT_FINISHED_FAILED',
  E_NOT_PREPARED: 'E_NOT_PREPARED',
  E_NOT_ENDED: 'E_NOT_ENDED',
  E_ALREADY_OWNED: 'E_ALREADY_OWNED',
  E_DEVELOPER_ERROR: 'E_DEVELOPER_ERROR',
  E_BILLING_RESPONSE_JSON_PARSE_ERROR: 'E_BILLING_RESPONSE_JSON_PARSE_ERROR',
});

declare type Common = {
  title: string,
  description: string,
  price: string,
  currency: string,
  localizedPrice: string,
}

declare type ID = string

declare type Discount = {
  identifier: string,
  type: string,
  numberOfPeriods: string,
  price: string,
  localizedPrice: string,
  paymentMode: string,
  subscriptionPeriod: string,
}

export type Product<ID> = Common & {
  type: "inapp" | "iap",
  productId: ID,
}

export type Subscription<ID> = Common & {
  type: "subs" | "sub",
  productId: ID,
  discounts?: Discount[],

  introductoryPrice?: string,
  introductoryPricePaymentModeIOS?: string,
  introductoryPriceNumberOfPeriods?: number,
  introductoryPriceSubscriptionPeriod: {},

  subscriptionPeriodNumberIOS?: number,
  subscriptionPeriodUnitIOS?: string,

  introductoryPriceCyclesAndroid?: number,
  introductoryPricePeriodAndroid?: string,
  subscriptionPeriodAndroid?: string,
  freeTrialPeriodAndroid: string,
}

export type ProductPurchase = {|
  productId: string,
  transactionId?: string,
  transactionDate: number,
  transactionReceipt: string,
  purchaseToken?: string,
  dataAndroid?: string,
  signatureAndroid?: string,
  autoRenewingAndroid?: boolean,
  isAcknowledgedAndroid?: boolean,
  purchaseStateAndroid?: number,
  originalTransactionDateIOS?: string,
  originalTransactionIdentifierIOS?: string,
|}

export type PurchaseResult = {
  responseCode: number,
  debugMessage: string,
  code: number,
  message: string,
}

export type PurchaseError = {
  responseCode: number,
  debugMessage: string,
  code: number,
  message: string,
}

export type SubscriptionPurchase = ProductPurchase & {
  autoRenewingAndroid: boolean,
  originalTransactionDateIOS: string,
  originalTransactionIdentifierIOS: string,
}

export type Purchase = ProductPurchase | SubscriptionPurchase

declare module.exports: {
  IAPErrorCode: typeof IAPErrorCode,
  getProducts: (string[]) => Promise<Product<string>[]>,
  getSubscriptions(string[]): Promise<Subscription<string>[]>,
  initConnection(): Promise<boolean>,
  buydProductWithOffer: (sku: string, forUser: string, withOffer: PaymentDiscount) => Promise<void>,
  endConnectionAndroid: () => Promise<void>,
  consumeAllItemsAndroid(): Promise<void>,
  getPurchaseHistory(): Promise<Purchase[]>,
  getAvailablePurchases(): Promise<Purchase[]>,
  buyProduct: string => Promise<ProductPurchase>,
  requestPurchase(
    sku: string,
    andDangerouslyFinishTransactionAutomatically: boolean,
  ): Promise<string>,
  buySubscription(
    sku: string,
    oldSku?: string,
    prorationMode?: number,
  ): Promise<SubscriptionPurchase>,
  requestSubscription: string => Promise<string>,
  buyProductWithQuantityIOS(
    sku: string,
    quantity: number,
  ): Promise<ProductPurchase>,
  requestPurchaseWithQuantityIOS(
    sku: string,
    quantity: number,
  ): Promise<string>,
  finishTransactionIOS(transactionId: string): void,
  clearTransactionIOS(): void,
  clearProductsIOS(): void,
  acknowledgePurchaseAndroid(token: string, developerPayload?: string): Promise<PurchaseResult>,
  consumePurchaseAndroid(token: string, developerPayload?: string): Promise<PurchaseResult>,
  validateReceiptIos(
    receiptBody: AppleReceiptValidationRequest,
    isTest: boolean,
  ): Promise<AppleReceiptValidationResponse | false>,
  validateReceiptAndroid(
    packageName: string,
    productId: string,
    productToken: string,
    accessToken: string,
    isSub: boolean,
  ): Promise<{} | false>,
  addAdditionalSuccessPurchaseListenerIOS(
    fn: (any) => any,
  ): EmitterSubscription,
  purchaseUpdatedListener(
    fn: (ProductPurchase) => any,
  ): EmitterSubscription,
  purchaseErrorListener(
    fn: (PurchaseError) => any,
  ): EmitterSubscription,
  getPendingPurchasesIOS(): Promise<ProductPurchase[]>,
  getPromotedProductIOS(): Promise<Product<string>>,
  buyPromotedProductIOS(): Promise<void>,
}

/**
 * Payment discount interface @see https://developer.apple.com/documentation/storekit/skpaymentdiscount?language=objc
 */
declare type PaymentDiscount = {
  /**
   * A string used to uniquely identify a discount offer for a product.
   */
  identifier: string,

  /**
   * A string that identifies the key used to generate the signature.
   */
  keyIdentifier: string,

  /**
   * A universally unique ID (UUID) value that you define.
   */
  nonce: string,

  /**
   * A UTF-8 string representing the properties of a specific discount offer, cryptographically signed.
   */
  signature: string,

  /**
   * The date and time of the signature's creation in milliseconds, formatted in Unix epoch time.
   */
  timestamp: number,
}


// TODO: the following definitions should be more specific

export type AppleReceiptValidationResponse = any
export type AppleReceiptValidationRequest = any
export type EmitterSubscription = any
