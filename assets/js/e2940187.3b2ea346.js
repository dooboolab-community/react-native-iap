"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5776],{3905:(e,n,t)=>{t.d(n,{Zo:()=>l,kt:()=>d});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=r.createContext({}),u=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},l=function(e){var n=u(e.components);return r.createElement(c.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},h=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,s=e.originalType,c=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),h=u(t),d=a,m=h["".concat(c,".").concat(d)]||h[d]||p[d]||s;return t?r.createElement(m,o(o({ref:n},l),{},{components:t})):r.createElement(m,o({ref:n},l))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var s=t.length,o=new Array(s);o[0]=h;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=e,i.mdxType="string"==typeof e?e:a,o[1]=i;for(var u=2;u<s;u++)o[u]=t[u];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}h.displayName="MDXCreateElement"},1614:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>u});var r=t(7462),a=(t(7294),t(3905));const s={sidebar_position:3},o="Purchases",i={unversionedId:"guides/purchases",id:"guides/purchases",title:"Purchases",description:"Purchase Flow Redesign",source:"@site/docs/guides/purchases.md",sourceDirName:"guides",slug:"/guides/purchases",permalink:"/docs/guides/purchases",draft:!1,editUrl:"https://github.com/dooboolab/react-native-iap/edit/main/docs/docs/guides/purchases.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Lifecycle",permalink:"/docs/guides/lifecycle"},next:{title:"Receipts",permalink:"/docs/guides/receipts"}},c={},u=[{value:"New Purchase Flow",id:"new-purchase-flow",level:2},{value:"Finishing a Purchase",id:"finishing-a-purchase",level:2}],l={toc:u};function p(e){let{components:n,...s}=e;return(0,a.kt)("wrapper",(0,r.Z)({},l,s,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"purchases"},"Purchases"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"\u26a0\ufe0f ",(0,a.kt)("strong",{parentName:"p"},"Purchase Flow Redesign")," \u26a0\ufe0f"),(0,a.kt)("p",{parentName:"blockquote"},"The ",(0,a.kt)("inlineCode",{parentName:"p"},"purchase")," flow has been updated as a result of the findings in issue ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/dooboolab/react-native-iap/issues/307"},"#307"),".\nThe resulting flow has been redesign to not rely on ",(0,a.kt)("inlineCode",{parentName:"p"},"Promise")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"Callback"),"."),(0,a.kt)("p",{parentName:"blockquote"},"Below are some of the specific reasons for the redesign:"),(0,a.kt)("ol",{parentName:"blockquote"},(0,a.kt)("li",{parentName:"ol"},"There may be more than one response when requesting a payment."),(0,a.kt)("li",{parentName:"ol"},"Purchases are inter-session ",(0,a.kt)("inlineCode",{parentName:"li"},"asynchronuous")," meaning requests that are made may take several hours to complete and continue to exist even after the app has been closed or crashed."),(0,a.kt)("li",{parentName:"ol"},"The purchase may be pending and hard to track what has been done (",(0,a.kt)("a",{parentName:"li",href:"https://github.com/dooboolab/react-native-iap/issues/307"},"example"),"."),(0,a.kt)("li",{parentName:"ol"},"The Billing Flow is an ",(0,a.kt)("inlineCode",{parentName:"li"},"event")," pattern rather than a ",(0,a.kt)("inlineCode",{parentName:"li"},"callback")," pattern."))),(0,a.kt)("p",null,"Once you have called ",(0,a.kt)("inlineCode",{parentName:"p"},"getProducts()"),", and have a valid response, you can call ",(0,a.kt)("inlineCode",{parentName:"p"},"requestPurchase()"),". Subscribable products can be purchased just like consumable products and users can cancel subscriptions by using the iOS System Settings."),(0,a.kt)("p",null,"Before you request any purchase, you should set ",(0,a.kt)("inlineCode",{parentName:"p"},"purchaseUpdatedListener")," from ",(0,a.kt)("inlineCode",{parentName:"p"},"react-native-iap"),". It is recommended that you start listening to updates as soon as your application launches. And don't forget that even at launch you may receive successful purchases that either completed while your app was closed or that failed to be finished, consumed or acknowledged due to network errors or bugs."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"import {\n  initConnection,\n  purchaseErrorListener,\n  purchaseUpdatedListener,\n  type ProductPurchase,\n  type PurchaseError,\n  flushFailedPurchasesCachedAsPendingAndroid,\n} from 'react-native-iap';\n\nclass App extends Component {\n  purchaseUpdateSubscription = null;\n  purchaseErrorSubscription = null;\n\n  componentDidMount() {\n    initConnection().then(() => {\n      // we make sure that \"ghost\" pending payment are removed\n      // (ghost = failed pending payment that are still marked as pending in Google's native Vending module cache)\n      flushFailedPurchasesCachedAsPendingAndroid()\n        .catch(() => {\n          // exception can happen here if:\n          // - there are pending purchases that are still pending (we can't consume a pending purchase)\n          // in any case, you might not want to do anything special with the error\n        })\n        .then(() => {\n          this.purchaseUpdateSubscription = purchaseUpdatedListener(\n            (\n              purchase: InAppPurchase | SubscriptionPurchase | ProductPurchase,\n            ) => {\n              console.log('purchaseUpdatedListener', purchase);\n              const receipt = purchase.transactionReceipt;\n              if (receipt) {\n                yourAPI\n                  .deliverOrDownloadFancyInAppPurchase(\n                    purchase.transactionReceipt,\n                  )\n                  .then(async (deliveryResult) => {\n                    if (isSuccess(deliveryResult)) {\n                      // Tell the store that you have delivered what has been paid for.\n                      // Failure to do this will result in the purchase being refunded on Android and\n                      // the purchase event will reappear on every relaunch of the app until you succeed\n                      // in doing the below. It will also be impossible for the user to purchase consumables\n                      // again until you do this.\n\n                      // If consumable (can be purchased again)\n                      await finishTransaction({purchase, isConsumable: true});\n                      // If not consumable\n                      await finishTransaction({purchase, isConsumable: false});\n                    } else {\n                      // Retry / conclude the purchase is fraudulent, etc...\n                    }\n                  });\n              }\n            },\n          );\n\n          this.purchaseErrorSubscription = purchaseErrorListener(\n            (error: PurchaseError) => {\n              console.warn('purchaseErrorListener', error);\n            },\n          );\n        });\n    });\n  }\n\n  componentWillUnmount() {\n    if (this.purchaseUpdateSubscription) {\n      this.purchaseUpdateSubscription.remove();\n      this.purchaseUpdateSubscription = null;\n    }\n\n    if (this.purchaseErrorSubscription) {\n      this.purchaseErrorSubscription.remove();\n      this.purchaseErrorSubscription = null;\n    }\n  }\n}\n")),(0,a.kt)("p",null,"Then define the method like below and call it when user press the button."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"class App extends Component {\n  requestPurchase = async (sku: string) => {\n    try {\n      await requestPurchase({\n        sku,\n        andDangerouslyFinishTransactionAutomaticallyIOS: false,\n      });\n    } catch (err) {\n      console.warn(err.code, err.message);\n    }\n  };\n\n  requestSubscription = async (sku: string, offerToken: string?) => {\n    try {\n      await requestSubscription(\n        {sku},\n        ...(offerToken && {subscriptionOffers: [{sku, offerToken}]}),\n      );\n    } catch (err) {\n      console.warn(err.code, err.message);\n    }\n  };\n\n  /**\n   * For one-time products\n   */\n  render() {\n    return (\n      <Pressable onPress={() => this.requestPurchase(product.productId)}>\n        {/* ... */}\n      </Pressable>\n    );\n  }\n\n  /**\n   * For subscriptions products\n   */\n  render() {\n    if (Platform.OS == 'android') {\n      return product.subscriptionOfferDetails.map((offer) => (\n        <Pressable\n          onPress={() =>\n            this.requestSubscription(product.productId, offer.offerToken)\n          }\n        >\n          {/* ... */}\n        </Pressable>\n      ));\n    } else {\n      return (\n        <Pressable\n          onPress={() => this.requestSubscription(product.productId, null)}\n        >\n          {/* ... */}\n        </Pressable>\n      );\n    }\n  }\n}\n")),(0,a.kt)("h2",{id:"new-purchase-flow"},"New Purchase Flow"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"purchase-flow-sequence",src:t(43).Z,width:"1154",height:"989"})),(0,a.kt)("p",null,"Most likely, you'll want to handle the \u201cstore kit flow\u201d","[",(0,a.kt)("sup",null,"[","2","]"),"][apple-store-kit-flow]",",\nwhich happens when a user successfully pays after solving a problem with his or her account \u2013 for example, when the credit card information has expired."),(0,a.kt)("p",null,"For above reason, we decided to remove ",(0,a.kt)("del",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"del"},"buyProduct"))," and use ",(0,a.kt)("inlineCode",{parentName:"p"},"requestPurchase")," instead which doesn't rely on promise function. The ",(0,a.kt)("inlineCode",{parentName:"p"},"purchaseUpdatedListener")," will receive the success purchase and ",(0,a.kt)("inlineCode",{parentName:"p"},"purchaseErrorListener")," will receive all the failure result that occurred during the purchase attempt."),(0,a.kt)("h2",{id:"finishing-a-purchase"},"Finishing a Purchase"),(0,a.kt)("p",null,"Purchases will keep being emitted to your ",(0,a.kt)("inlineCode",{parentName:"p"},"purchaseUpdatedListener")," on every app relaunch until you finish the purchase."),(0,a.kt)("p",null,"All purchases should be consumed by calling ",(0,a.kt)("inlineCode",{parentName:"p"},"finishTransaction()"),"."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"For consumables: Once an item is consumed, it will be removed from ",(0,a.kt)("inlineCode",{parentName:"li"},"getAvailablePurchases()")," so it is up to you to record the purchase into your database before calling ",(0,a.kt)("inlineCode",{parentName:"li"},"finishTransaction()"),"."),(0,a.kt)("li",{parentName:"ul"},"For non-consumable purchases need to be acknowledged on Android, or they will be automatically refunded after a few days. This method acknowledges a purchase when you have delivered it to your user."),(0,a.kt)("li",{parentName:"ul"},"On iOS non-consumable purchases are finished automatically but this will change in the future so it is recommended that you prepare by simply calling this method on non-consumables as well."),(0,a.kt)("li",{parentName:"ul"},"It works for both platforms. Equal to finishTransaction for iOS + consumePurchase and acknowledgePurchase for Android.")))}p.isMDXComponent=!0},43:(e,n,t)=>{t.d(n,{Z:()=>r});const r=t.p+"assets/images/react-native-iapv3-8467b005f57bac1f11896c06e15577aa.svg"}}]);